package com.advertisement.network;import java.util.Timer;import java.util.TimerTask;import android.nfc.Tag;import android.os.Message;import android.text.format.Time;import android.util.Log;import com.advertisement.network.NetworkProtocol.FrameHead;import com.advertisement.system.ConstData;import com.advertisement.system.SystemManager;import com.common.AppLog;import com.common.Mutex;public class NetworkProcess {    public NetworkManager mNetworkManager=null;    private static final String TAG="NetworkProcess";    private enum ProcessState{        STATE_SYN_SESSION,//--启动会话        STATE_FIN_SESSION,//--结束会话        STATE_INSTALL,    //--安装设备        STATE_AUTH,       //--身份认证        STATE_ALIVE,      //--心跳        STATE_TRANS_REQ,  //--传输请求        STATE_TRANS_STATUS,//--传输进度上报        STATE_SEND_PACKET,  //--发送数据        STATE_IDLE        //--空闲    }    private Mutex mStateMutex=new Mutex();    private ProcessState mState=ProcessState.STATE_IDLE;    //--终端->平台数据缓存    private byte[] RequestBuf=new byte[ConstData.NETOWRK_ANALYSE_BUF_SIZE];    private int RequestLen=0;    private int recvOffer=0;    private int lastOffer=0;    //--平台->终端数据缓存    private byte[] RespondBuf=new byte[ConstData.NETWORK_RECV_BUF_SIZE];    private int RespondLen=0;    //--应答报文流水号    private int mAckSn=0;    //--发送报文流水号    private int mTxSn=0;    //--应用层流水号    private int mMsgSn=0;    //--心跳计数时间    private Time mAliveStartTime=new Time();    private Time mCurTime=new Time();    private NetworkCmdExec mNetworkCmdExec=new NetworkCmdExec();    public NetworkProcess(NetworkManager manager) {        // TODO Auto-generated constructor stub        mNetworkManager=manager;    }    public void initConfig(){        mAckSn=0;        mTxSn=0;        mMsgSn=0;        RequestLen=0;        recvOffer=0;        lastOffer=0;        mAliveStartTime.setToNow();    }    private void sendData(byte[] data,int datalen){        mNetworkManager.SendDataToServer(RequestBuf, RequestLen);        //--每次发送完数据清理心跳时间        mAliveStartTime.setToNow();    }    public void requestSynSession(){        SystemManager.LOGI(TAG,"requestSynSession entry");        if(!mStateMutex.lock(3000)){            SystemManager.LOGI(TAG,"requestSynSession exit FAIL!");            return ;        }        mState=ProcessState.STATE_SYN_SESSION;        //--产生新会话，流水号等参数需要归零        initConfig();        NetworkProtocol packet=new NetworkProtocol();        packet.head.flag=FrameHead.FLAG_SYN|FrameHead.FLAG_EOT;        packet.head.rsvd=FrameHead.RSVD_APP;        packet.head.conn_id=(FrameHead.CONNID_DEF_NO<<12)|FrameHead.CONNID_DEF_ID;        packet.head.tx_sn=++mTxSn;        packet.head.ack_sn=mAckSn;        packet.head.len=0;        packet.head.sum=0;        //--预先将数据拷贝到缓存中        packet.head.toBytes(RequestBuf,0);        //--根据缓存中的数据计算校验和        packet.head.sum=packet.calcCheckSum(RequestBuf);        //--校验和写入数据缓存中        packet.head.toBytes(RequestBuf,0);        //--计算报文长度        RequestLen=FrameHead.FRAME_HEAD_LEN+packet.head.len;        //--发送报文        sendData(RequestBuf,RequestLen);        mStateMutex.unlock();        SystemManager.LOGI(TAG,"requestSynSession exit");    }    public void requestFinSession(){        if(!mStateMutex.lock(3000)){            return ;        }        mState=ProcessState.STATE_FIN_SESSION;        mStateMutex.unlock();    }    public void sendAlivePacket(){        Log.e(TAG,"sendAlivePacket");        NetworkProtocol packet=new NetworkProtocol();        //--填充HEAD        packet.head.flag=FrameHead.FLAG_EOT;        packet.head.rsvd=FrameHead.RSVD_ALIVE;        packet.head.conn_id=(FrameHead.CONNID_DEF_NO<<12)|FrameHead.CONNID_DEF_ID;        packet.head.tx_sn=createTxSn();        packet.head.ack_sn=mAckSn;        packet.head.sum=0;        packet.head.len=0;        packet.head.toBytes(RequestBuf, 0);        packet.head.sum=packet.calcCheckSum(RequestBuf);        packet.head.toBytes(RequestBuf, 0);        RequestLen=FrameHead.FRAME_HEAD_LEN;        mNetworkManager.SendDataToServer(RequestBuf, RequestLen);        SystemManager.LOGD(TAG,"sendAlivePacket"+System.currentTimeMillis()+packet.toString());    }    public void requestAlive(){        //--判断是否已经安装，安装成功之后才能发送心跳包        if(!SystemManager.getSystemManager().getConfig().installState){            return ;        }		/*		//--判断是否到达心跳时间		mCurTime.setToNow();		if((mCurTime.toMillis(false)-mAliveStartTime.toMillis(false))<				(SystemManager.getSystemManager().getConfig().aliveTime*1000)){						return ;		}		*/        if(!mStateMutex.lock(3000)){            SystemManager.LOGI(TAG,"requestAlive exit FAIL!");            return ;        }        mState=ProcessState.STATE_ALIVE;        sendAlivePacket();        mStateMutex.unlock();    }    public void requestInstall(NetworkProtocol.FrameHead recvHead){        SystemManager.LOGI(TAG,"======================");        if(!mStateMutex.lock(3000)){            SystemManager.LOGI(TAG," requestInstall fail!");            return ;        }        SystemManager.LOGI(TAG," requestInstall ");        String installNumber=SystemManager.getSystemManager().getConfig().installJobNum;        mState=ProcessState.STATE_INSTALL;        NetworkProtocol packet=new NetworkProtocol();        //--填充HEAD        packet.head.flag=FrameHead.FLAG_EOT;        packet.head.rsvd=FrameHead.RSVD_APP;        packet.head.conn_id=recvHead.conn_id;//*保留平台下发的CONN_ID        packet.head.tx_sn=createTxSn();        packet.head.ack_sn=mAckSn;        packet.head.sum=0;        packet.head.len=installNumber.getBytes().length+6;        //--填充BODY        packet.body.msg_code=0X00D0;        packet.body.msg_len=packet.head.len-4;        packet.body.msg_sn=createMsgSn();        packet.body.msg_body=new byte[packet.body.msg_len-2];        System.arraycopy(installNumber.getBytes() , 0, packet.body.msg_body, 0, installNumber.getBytes().length);        //--计算校验值        packet.head.toBytes(RequestBuf, 0);        packet.body.toBytes(RequestBuf, FrameHead.FRAME_HEAD_LEN);        packet.head.sum=packet.calcCheckSum(RequestBuf);        packet.head.toBytes(RequestBuf, 0);        RequestLen=packet.head.len+FrameHead.FRAME_HEAD_LEN;        sendData(RequestBuf, RequestLen);        mStateMutex.unlock();        //--设置安装超时        new Timer().schedule(new TimerTask() {            @Override            public void run() {                //--若安装成功，会在NetworkCmdExec中直接上报,否则超时上报安装状态                if(!SystemManager.getSystemManager().getConfig().installState){                    //--上报系统管理器安装状态                    Message msg=new Message();                    msg.what=ConstData.SystemMsgType.MSG_REPORT_INSTALL_STATUS;                    mNetworkManager.mSystemManager.sendMsgToSystem(msg);                }            }        }, 15000);        SystemManager.LOGI(TAG,"======================");    }    public void requestAuth(){        if(!mStateMutex.lock(3000)){            return ;        }        mState=ProcessState.STATE_AUTH;        mStateMutex.unlock();    }    public void requestTrans(){        if(!mStateMutex.lock(3000)){            return ;        }        mState=ProcessState.STATE_TRANS_REQ;        mStateMutex.unlock();    }    public void requestTransStatus(byte dir,String fileName,byte status){        if(!mStateMutex.lock(3000)){            return ;        }        SystemManager.LOGI(TAG,"=== requestTransStatus ===");        mState=ProcessState.STATE_TRANS_STATUS;        NetworkProtocol packet=new NetworkProtocol();        //--填充HEAD        packet.head.flag=FrameHead.FLAG_EOT;        packet.head.rsvd=FrameHead.RSVD_APP;        packet.head.conn_id=(FrameHead.CONNID_DEF_NO<<12)|FrameHead.CONNID_DEF_ID;        packet.head.tx_sn=createTxSn();        packet.head.ack_sn=mAckSn;        packet.head.sum=0;        packet.head.len=10+fileName.length();        packet.head.toBytes(RequestBuf, 0);        //--填充body        packet.body.msg_code=0X00DA;        packet.body.msg_len=packet.head.len-4;        packet.body.msg_sn=1;        packet.body.msg_body=new byte[fileName.length()+4];        packet.body.msg_body[0]=(byte)(dir&0xff);        packet.body.msg_body[1]=(byte)(status&0xff);        packet.body.msg_body[2]=(byte)(fileName.length()&0xff);        packet.body.msg_body[3]=(byte)((fileName.length())>>8&0xff);        System.arraycopy(fileName.getBytes(), 0, packet.body.msg_body, 4, fileName.length());        packet.body.toBytes(RequestBuf, FrameHead.FRAME_HEAD_LEN);        packet.head.sum=packet.calcCheckSum(RequestBuf);        packet.head.toBytes(RequestBuf, 0);        RequestLen=FrameHead.FRAME_HEAD_LEN+packet.head.len;        mNetworkManager.SendDataToServer(RequestBuf, RequestLen);        showPacket(packet);        mStateMutex.unlock();    }    public void createAckHead(NetworkProtocol.FrameHead reqHead,NetworkProtocol.FrameHead ackHead){        ackHead.flag=FrameHead.FLAG_EOT;        ackHead.rsvd=FrameHead.RSVD_ACK;        ackHead.conn_id=reqHead.conn_id;        ackHead.ack_sn=reqHead.tx_sn;    //--使用平台产生的发送序列当作应答序列    }    public void sendAckPacket(NetworkProtocol packet){        if(!mStateMutex.lock(0)){            return ;        }        packet.head.tx_sn=createTxSn();        packet.head.toBytes(RequestBuf, 0);        if(packet.head.len>0){            packet.body.toBytes(RequestBuf, FrameHead.FRAME_HEAD_LEN);        }        packet.head.sum=0;        packet.head.sum=packet.calcCheckSum(RequestBuf);        packet.head.toBytes(RequestBuf, 0);        RequestLen=FrameHead.FRAME_HEAD_LEN+packet.head.len;        SystemManager.LOGI(TAG,"=== sendAckPacket ===");        SystemManager.LogHex(TAG,RequestBuf,RequestLen);        SystemManager.LOGI(TAG,"=====================");        sendData(RequestBuf, RequestLen);        mStateMutex.unlock();    }    public void showPacket(NetworkProtocol packet){        SystemManager.LOGI(TAG, "=====================");        SystemManager.LOGI(TAG, "FLAG:"+SystemManager.outHexStr((byte)(packet.head.flag&0xff)));        SystemManager.LOGI(TAG, "RSVD:"+SystemManager.outHexStr((byte)(packet.head.rsvd&0xff)));        SystemManager.LOGI(TAG, "CONN_ID:"+SystemManager.outHexStr((byte)((packet.head.conn_id>>8)&0xff))+                SystemManager.outHexStr((byte)(packet.head.conn_id&0xff)));        SystemManager.LOGI(TAG, "TX_SN:"+packet.head.tx_sn);        SystemManager.LOGI(TAG, "ACK_SN:"+packet.head.ack_sn);        SystemManager.LOGI(TAG, "SUM:"+SystemManager.outHexStr((byte)(packet.head.sum&0xff))+" "+                SystemManager.outHexStr((byte)((packet.head.sum>>8)&0xff)));        SystemManager.LOGI(TAG, "LEN:"+packet.head.len);        if(packet.head.len>0){            SystemManager.LOGI(TAG, "MSG_CODE:"+SystemManager.outHexStr((byte)((packet.body.msg_code>>8)&0xff))+                    SystemManager.outHexStr((byte)(packet.body.msg_code&0xff)));            SystemManager.LOGI(TAG, "MSG_LEN:"+packet.body.msg_len);        }        SystemManager.LOGI(TAG, "=====================");    }    public void doRecvData(byte[] data,int datalen){        SystemManager.LOGD(TAG, "~~~~~~~~~~~~~~~~~~~~~~");        SystemManager.LOGI(TAG, "  doRecvData ");        //--防止断包,防止溢出        if((recvOffer+datalen)>RespondBuf.length){            recvOffer=0;            RespondLen=0;            lastOffer=0;            SystemManager.LOGE(TAG, "  Over memory buffer ");            return ;        }else{            System.arraycopy(data, 0, RespondBuf,recvOffer, datalen);        }        RespondLen+=datalen;        recvOffer+=datalen;        do{            NetworkProtocol packet=new NetworkProtocol();            if(RespondLen<FrameHead.FRAME_HEAD_LEN){                SystemManager.LOGE(TAG, "len < FRAME_HEAD_LEN");                return ;            }            packet.head.toHead(RespondBuf, lastOffer);            if(RespondLen<(FrameHead.FRAME_HEAD_LEN+packet.head.len)){                SystemManager.LOGE(TAG, "total len < FRAME_HEAD_LEN+len");                return ;            }            int sum=packet.head.sum;            packet.head.sum=0;            packet.head.toBytes(RespondBuf, lastOffer);            if(packet.calcCheckSum(RespondBuf,lastOffer)!=sum){                SystemManager.LOGE(TAG, "check sum fail!");                SystemManager.LOGE(TAG, "recv sum:"+sum+" need sum:"+packet.calcCheckSum(RespondBuf));                return ;            }            packet.head.sum=sum;            if(packet.head.len>0){                packet.body.toBody(RespondBuf,FrameHead.FRAME_HEAD_LEN+lastOffer);            }            showPacket(packet);            switch(packet.head.flag){                case FrameHead.FLAG_SYN:                    SystemManager.LOGI(TAG, "SYN");                    break;                case FrameHead.FLAG_FIN:                    SystemManager.LOGI(TAG, "FIN");                    break;                case FrameHead.FLAG_EOT:                    SystemManager.LOGI(TAG, "EOT");                    if(packet.head.len>0){                        doAnalysePacket(RespondBuf,RespondLen,packet);                    }                    break;            }            lastOffer+=FrameHead.FRAME_HEAD_LEN+packet.head.len;            RespondLen-=(FrameHead.FRAME_HEAD_LEN+packet.head.len);        }while(RespondLen!=0);//--连续处理多个请求包        lastOffer=0;        recvOffer=0;        RespondLen=0;        SystemManager.LOGD(TAG, "~~~~~~~~~~~~~~~~~~~~~~");    }    public void doAnalysePacket(byte[] data,int datalen,NetworkProtocol  packet){        SystemManager.LOGI(TAG, "=====================");        SystemManager.LOGI(TAG, "  doAnalysePacket");        SystemManager.LOGI(TAG, "=====================");        for(NetworkCmdExec.CmdExec exec:mNetworkCmdExec.getCmdExecList()){            if(exec.cmdId==packet.body.msg_code){                exec.onExec(this, data, datalen, packet);            }        }    }    public int createTxSn(){        mTxSn++;        if(mTxSn==0){            mTxSn++;        }        return mTxSn;    }    public int getAckSn(){        return mAckSn;    }    public int createMsgSn(){        mMsgSn++;        if(mMsgSn==0){            mMsgSn++;        }        return mMsgSn;    }    public int getMsgSn(){        return mMsgSn;    }}