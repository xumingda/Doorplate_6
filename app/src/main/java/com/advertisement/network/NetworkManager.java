package com.advertisement.network;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.IOException;import java.io.PrintWriter;import java.io.StringWriter;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;import java.net.SocketException;import java.net.SocketTimeoutException;import java.net.UnknownHostException;import java.util.ArrayList;import java.util.HashMap;import android.R.integer;import android.annotation.SuppressLint;import android.content.BroadcastReceiver;import android.content.Context;import android.content.Intent;import android.content.IntentFilter;import android.net.ConnectivityManager;import android.net.NetworkInfo;import android.os.Handler;import android.os.Message;import android.util.Log;import com.advertisement.system.BaseManager;import com.advertisement.system.ConstData;import com.advertisement.system.SystemManager;import com.common.Mutex;public class NetworkManager extends BaseManager {	private NetworkHandler mHandler = null;	private NetworkTask mTask = null;	private Mutex mStateMutex = new Mutex();	private Mutex mTaskMutex = new Mutex();	private Mutex mNetMutex = new Mutex();	private int mState = ConstData.NetworkState.STATE_INIT;	private boolean isNetworkOkay = false;	private byte[] mSendBuf = null;	private int mSendLen = 0;	private NetworkProcess mNetworkProcess = null;	private static final String TAG = "NetworkManager";	private enum TaskState {		STATE_CONNECT, STATE_DISCONNECT, STATE_RUNNING, STATE_ALIVE, STATE_ERROR, STATE_UNKNOWN	}	public NetworkManager(SystemManager systemManager) {		super(systemManager);		// *注册消息handler		mHandler = new NetworkHandler();		// *初始化状态机		setState(ConstData.NetworkState.STATE_INIT);		mNetworkProcess = new NetworkProcess(this);	}	private void setState(int state) {		if (mStateMutex.lock(10)) {			mState = state;			mStateMutex.unlock();		}	}	@Override	public void start() {		isNetworkOkay = false;		checkNetworkHw();		// *创建网卡状态变化广播接收		IntentFilter intentFilter = new IntentFilter();		intentFilter.addAction(ConnectivityManager.CONNECTIVITY_ACTION);		mSystemManager.getContext().registerReceiver(connectionReceiver,				intentFilter);	}	@Override	public void stop() {		stopTask();		mSystemManager.getContext().unregisterReceiver(connectionReceiver);	}	public void stopForced() {		if (mTask != null) {			mTask.interrupt();			mTask.stopForced();		}		stop();	}	@Override	public Handler getHandler() {		return mHandler;	}	@Override	public int getState() {		// TODO Auto-generated method stub		return 0;	}	private boolean checkNetworkHw() {		Log.e(TAG,"checkNetworkHw");		boolean isOkay = false;		ConnectivityManager connectMgr = (ConnectivityManager) mSystemManager				.getContext().getSystemService(Context.CONNECTIVITY_SERVICE);		NetworkInfo ethNetInfo = connectMgr				.getNetworkInfo(ConnectivityManager.TYPE_ETHERNET);		NetworkInfo wifiNetInfo = connectMgr				.getNetworkInfo(ConnectivityManager.TYPE_WIFI);		// SystemManager.LOGI(TAG,"eth connect:"+ethNetInfo.isConnected());		// SystemManager.LOGI(TAG,"wifi connect:"+wifiNetInfo.isConnected());		// SystemManager.LOGI(TAG,"eth isAvailable:"+ethNetInfo.isAvailable());		// SystemManager.LOGI(TAG,"wifi isAvailable:"+wifiNetInfo.isAvailable());		if (!ethNetInfo.isConnected() && !wifiNetInfo.isConnected()) {			SystemManager.LOGI(TAG, "connectionReceiver->disConnected!");			// --网卡未开启（以太网或者wifi关闭了）			isOkay = false;		} else {			// --wifi或者以太网以开启			SystemManager.LOGI(TAG, "connectionReceiver->Connected!");			if (!ethNetInfo.isAvailable() && !wifiNetInfo.isAvailable()) { // --无法获取IP或者无法正常使用				SystemManager.LOGI(TAG,						"connectionReceiver->isAvailable false!");				isOkay = false;			} else {// --网卡正常使用				SystemManager						.LOGI(TAG, "connectionReceiver->isAvailable true!");				isOkay = true;			}		}		if (isOkay) {			// mHandler.sendEmptyMessage(ConstData.NetworkMsgType.MSG_NETWORK_ENABLED);			// --通知资源管理器，网络可用			Message msg = new Message();			msg.what = ConstData.ResMsgType.MSG_NETWORK_ENABLED;			mSystemManager					.sendMsgToManager(mSystemManager.getResManager(), msg);		} else {			// mHandler.sendEmptyMessage(ConstData.NetworkMsgType.MSG_NETWORK_DISABLED);			// --通知资源管理器，网络不可用			Message msg = new Message();			msg.what = ConstData.ResMsgType.MSG_NETWORK_DISABLED;			mSystemManager					.sendMsgToManager(mSystemManager.getResManager(), msg);		}		return isOkay;	}	BroadcastReceiver connectionReceiver = new BroadcastReceiver() {		@Override		public void onReceive(Context context, Intent intent) {			checkNetworkHw();		}	};	@SuppressLint("HandlerLeak")	private class NetworkHandler extends Handler {		@Override		public void handleMessage(Message msg) {			// TODO Auto-generated method stub			super.handleMessage(msg);			Log.e(TAG,"msg.what:"+msg.what);			switch (msg.what) {			case ConstData.NetworkMsgType.MSG_NETWORK_ENABLED:				if (isNetworkOkay == false) {					 startTask();//--启动网络协议任务				}				isNetworkOkay = true;				setState(ConstData.NetworkState.STATE_NETWORK_ENABLED);				break;			case ConstData.NetworkMsgType.MSG_NETWORK_DISABLED:				if (isNetworkOkay == true) {					// stopTask();//*停止网络协议任务				}				isNetworkOkay = false;				setState(ConstData.NetworkState.STATE_NETWORK_DISABLED);				break;			case ConstData.NetworkMsgType.MSG_CONNECTED:				setState(ConstData.NetworkState.STATE_CONNECTED);				// --启动会话				// mNetworkProcess.requestSynSession();				break;			case ConstData.NetworkMsgType.MSG_DISCONNECTED:				setState(ConstData.NetworkState.STATE_DISCONNECTED);				break;			case ConstData.NetworkMsgType.MSG_REPORT_TRANS_STATUS:// --上报传输状态				// mNetworkProcess.requestTransStatus((byte)(msg.arg1&0xff),				// (String)msg.obj, (byte)(msg.arg2));				break;			}		}	}	private void startTask() {		stopTask();		// --添加IP地址选择表		ArrayList<HashMap<String, String>> list = new ArrayList<HashMap<String, String>>();		HashMap<String, String> map = new HashMap<String, String>();		map.put("ip", mSystemManager.getConfig().serverIp);		map.put("port",				String.valueOf(mSystemManager.getConfig().serverPortNum));		list.add(map);		map = new HashMap<String, String>();		map.put("ip", mSystemManager.getConfig().serverIp2);		map.put("port",				String.valueOf(mSystemManager.getConfig().serverPortNum2));		list.add(map);		for (HashMap<String, String> m : list) {			SystemManager.LOGI(TAG, "IP:" + map.get("ip"));			SystemManager.LOGI(TAG, "PORT:" + map.get("port"));		}		mTask = new NetworkTask(list, ConstData.NETWORK_SEND_BUF_SIZE,				ConstData.NETWORK_RECV_BUF_SIZE);		mTask.start();	}	private void stopTask() {		if (mTask != null) {			mTask.interrupt();			if (mTaskMutex					.lock((mSystemManager.getConfig().aliveTime * 1000) + 1)) {				mTask = null;				mTaskMutex.unlock();			}		}	}	private class NetworkTask extends Thread {		private byte[] recvbuf = null;		private int recvlen = 0;		private int sendMaxSize = 0;		private int recvMaxSize = 0;		private TaskState mTaskState = TaskState.STATE_UNKNOWN;		private ArrayList<HashMap<String, String>> mServerAddrList = new ArrayList<HashMap<String, String>>();		private int mServerSelectId = 0;		private Socket mSocket = null;		private DataOutputStream outputStream = null;		private DataInputStream inputStream = null;		private Mutex stateMutex = new Mutex();		private void setTaskState(TaskState state) {			stateMutex.lock(1);			mTaskState = state;			stateMutex.unlock();		}		public NetworkTask(ArrayList<HashMap<String, String>> serverAddrList,				int sendBufSize, int recvBufSize) {			// TODO Auto-generated constructor stub			this.mServerAddrList = serverAddrList;			this.sendMaxSize = sendBufSize;			this.recvMaxSize = recvBufSize;			this.recvbuf = new byte[this.recvMaxSize];			this.mServerSelectId = 0;		}		@Override		public void run() {			super.run();			mTaskMutex.lock(0);			setTaskState(TaskState.STATE_CONNECT);			while (!interrupted()) {				if (mTaskState == TaskState.STATE_CONNECT) {					onConnect();				} else if (mTaskState == TaskState.STATE_DISCONNECT) {					onDisconnect();				} else if (mTaskState == TaskState.STATE_RUNNING) {					onRunning();				} else if (mTaskState == TaskState.STATE_ALIVE) {					onAlive();				}			}			mTaskMutex.unlock();		}		public void stopForced() {			if (mTaskState == TaskState.STATE_RUNNING					|| mTaskState == TaskState.STATE_ALIVE) {				if (mSocket != null) {					try {						outputStream.flush();						outputStream.close();						inputStream.close();						mSocket.close();						mTaskState = TaskState.STATE_UNKNOWN;					} catch (IOException e) {						// TODO Auto-generated catch block						e.printStackTrace();					}				}			}		}		private boolean onConnect() {			Log.e(TAG,"onConnect");			if (mServerAddrList.size() == 0) {				setTaskState(TaskState.STATE_ERROR);				return false;			}			try {				mSocket = new Socket();				SocketAddress serverAddress = new InetSocketAddress(						mServerAddrList.get(mServerSelectId).get("ip"),						Integer.valueOf(mServerAddrList.get(mServerSelectId)								.get("port")));				SystemManager.LOGI(TAG, "CONNECT:" + serverAddress.toString());				// --设置连接服务器3秒超时,防止连接服务器卡死				mSocket.connect(serverAddress, 5000);				SystemManager.LOGI(TAG, "CONNECT OK!");				// --设置输入输出句柄				outputStream = new DataOutputStream(mSocket.getOutputStream());				inputStream = new DataInputStream(mSocket.getInputStream());				// --设置心跳时间作为传输接收超时				mSocket.setSoTimeout(mSystemManager.getConfig().aliveTime * 1000);				// --通知上层服务器连接成功				mHandler.sendEmptyMessage(ConstData.NetworkMsgType.MSG_CONNECTED);				setTaskState(TaskState.STATE_RUNNING);				return true;			} catch (NumberFormatException e) {				SystemManager.LOGE(TAG, "================");				SystemManager.LOGE(TAG, " onConnect NumberFormatException ");				e.printStackTrace();				SystemManager.LOGE(TAG, "================");				mSocket = null;			} catch (UnknownHostException e) {				SystemManager.LOGE(TAG, "================");				SystemManager.LOGE(TAG, " onConnect UnknownHostException ");				e.printStackTrace();				SystemManager.LOGE(TAG, "================");				mSocket = null;			} catch (IOException e) {				SystemManager.LOGE(TAG, "================");				SystemManager.LOGE(TAG, " onConnect IOException ");				e.printStackTrace();				SystemManager.LOGE(TAG, "================");				mSocket = null;			}			// --选择IP 端口地址			mServerSelectId++;			if (mServerSelectId == mServerAddrList.size()) {				mServerSelectId = 0;			}			return false;		}		private boolean onDisconnect() {			Log.e(TAG,"onDisconnect");			if (mSocket != null) {				try {					mSocket.close();				} catch (IOException e) {					e.printStackTrace();				}			}			mSocket = null;			setTaskState(TaskState.STATE_CONNECT);			// --通知上层服务器连接断开			mHandler.sendEmptyMessage(ConstData.NetworkMsgType.MSG_DISCONNECTED);			return true;		}		private void onRunning() {			try {				if (mSocket == null) {					return;				}				recvlen = inputStream.read(recvbuf, 0, recvMaxSize);				if (recvlen > 0) {					SystemManager.LOGI(TAG, "================");					SystemManager.LOGI(TAG, "recv data:");					SystemManager.LogHex(TAG, recvbuf, recvlen);					SystemManager.LOGI(TAG, "================");					mNetworkProcess.doRecvData(recvbuf, recvlen);				}			} catch (IOException e) {				// TODO Auto-generated catch block				if (e.getClass() == SocketTimeoutException.class) {					setTaskState(TaskState.STATE_ALIVE);				} else {					SystemManager.LOGE(TAG, "================");					SystemManager.LOGE(TAG, " onRunning IOException ");					e.printStackTrace();					// --断网					mTaskState = TaskState.STATE_DISCONNECT;					SystemManager.LOGE(TAG, "================");				}			}		}		private void onAlive() {			SystemManager.LOGI(TAG, "================");			SystemManager.LOGI(TAG, " onAlive ");			SystemManager.LOGI(TAG, "================");			setTaskState(TaskState.STATE_RUNNING);			if (mNetworkProcess != null) {				mNetworkProcess.requestAlive();			}		}		public boolean SendData(byte[] data, int datalen) {			if (mSocket != null) {				try {					outputStream.write(data, 0, datalen);					SystemManager.LOGI(TAG, "================");					SystemManager.LOGI(TAG, "send data:");					SystemManager.LogHex(TAG, data, datalen);					SystemManager.LOGI(TAG, "================");					return true;				} catch (IOException e) {					// TODO Auto-generated catch block					SystemManager.LOGE(TAG, "================");					SystemManager.LOGE(TAG, " SendData ");					e.printStackTrace();					SystemManager.LOGE(TAG, "================");					return false;				}			}			return false;		}	}	public void SendDataToServer(byte[] data, int datalen) {		// --判断当前是否连接到服务器		if (mState != ConstData.NetworkState.STATE_CONNECTED) {			return;		}		// --如果此时网络任务未启动不处理		if (mTask == null) {			return;		}		// --请求锁，进入发送状态，防止并发		if (!mNetMutex.lock(5000)) {			return;		}		mSendBuf = data;		mSendLen = datalen;		new Thread(new Runnable() {			@Override			public void run() {				// TODO Auto-generated method stub				mTask.SendData(mSendBuf, mSendLen);				mNetMutex.unlock();// --释放锁表示此时发送完成			}		}).start();		// --等待发送完成		if (mNetMutex.lock(1000)) {			mNetMutex.unlock();		}	}}